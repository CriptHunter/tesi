\documentclass[12pt,italian]{report}
\usepackage{tesi}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{xcolor}
\setcounter{tocdepth}{3} % subsubsec nell'indice
\setcounter{secnumdepth}{3}  % numerare subsubsec

\newcommand{\myparagraph}[1]{\paragraph{#1}\mbox{}\\}
%\usepackage[section]{placeins}

%
%			INFORMAZIONI SULLA TESI
%			DA COMPILARE!
%

% CORSO DI LAUREA:
\def\myCDL{Corso di Laurea magistrale in\\Informatica}
% TITOLO TESI:
\def\myTitle{Il titolo\\della tesi}

% AUTORE:
\def\myName{Lorenzo D'Alessandro}
\def\myMat{Matr. Nr. 939416}

% RELATORE E CORRELATORE:
\def\myRefereeA{Relatore 1}
\def\myRefereeB{Correlatore 1}

% ANNO ACCADEMICO
\def\myYY{2020-2021}

% Il seguente comando introduce un elenco delle figure dopo l'indice (facoltativo)
%\figurespagetrue

% Il seguente comando introduce un elenco delle tabelle dopo l'indice (facoltativo)
%\tablespagetrue

%
%			PREAMBOLO
%			Inserire qui eventuali package da includere o definizioni di comandi personalizzati
%

% Package di formato
\usepackage[a4paper]{geometry}		% Formato del foglio
\usepackage[italian]{babel}			% Supporto per l'italiano
\usepackage[utf8]{inputenc}			% Supporto per UTF-8
%\usepackage[a-1b]{pdfx}			% File conforme allo standard PDF-A (obbligatorio per la consegna)

% Package per la grafica
\usepackage{graphicx}				% Funzioni avanzate per le immagini
\usepackage{hologo}					% Bibtex logo with \hologo{BibTeX}
%\usepackage{epsfig}				% Permette immagini in EPS
%\usepackage{xcolor}				% Gestione avanzata dei colori

% Package tipografici
\usepackage{amssymb,amsmath,amsthm} % Simboli matematici
\usepackage{listings}				% Scrittura di codice

% Package ipertesto
\usepackage{url}					% Visualizza e rendere interattii gli URL
\usepackage{hyperref}				% Rende interattivi i collegamenti interni


\begin{document}

% Creazione automatica del frontespizio
\frontespizio
\beforepreface

% 
%			PAGINA DI DEDICA E/O CITAZIONE
%			facoltativa, questa è l'unica cosa che dovete formattare a mano, un po' come vi pare
%

{\raggedleft \large \sl Dedica \\}
         
% 
%			PREFAZIONE (facoltativa)
%

%\prefacesection{Prefazione}
%Le prefazioni non sono molto comuni, tuttavia a volte capita che qualcuno voglia dire qualcosa che esuli dal lavoro in s\'e (come un meta-commento sull'elaborato), o voglia fornire informazioni riguardanti l'eventuale progetto entro cui la tesi si colloca (in questo caso \`e probabile che sia il relatore a scrivere questa parte).

%
%			RINGRAZIAMENTI (facoltativi)
%

\prefacesection{Ringraziamenti}
Questa sezione, facoltativa, contiene i ringraziamenti.

%
%			Creazione automatica dell'indice
%

\afterpreface

% 
%			CAPITOLO 1: Introduzione o Abstract
% 

\chapter{Introduzione}
\label{cap:introduzione}

Introduzione...

\section{I contenuti}
\label{sec:contenuti}

Spiegazione problema...


\section{Organizzazione della tesi}
\label{sec:organizzazione}

Organizzazione tesi...

% 
%			CAPITOLO 2: Stato dell'arte
% 

\chapter{Stato dell'arte}
\label{chap:stato_arte}

%\input{capitoli/stato_arte.tex}

% 
%			CAPITOLO 3: Lavoro svolto
% 

\chapter{RS per dispositivi mobili e pervasivi}
\label{chap:classificatore}
La maggior parte dei RS producono le loro raccomandazioni usando unicamente informazioni su utenti, oggetti, e le valutazioni che gli utenti hanno dato agli oggetti (rating). Meno comuni sono invece i sistemi di raccomandazione context-aware, che considerano nel processo di raccomandazione anche il contesto in cui un rating è stato generato. La maggior parte dei CARS sfruttano un insieme limitato di feature di contesto selezionate manualmente, in modo da evitare di dover gestire una matrice dei rating con dimensionalità elevata. Recentemente sono stati proposti i primi sistemi di raccomandazioni context-aware che integrano nel processo di raccomandazione un alto numero di feature contestuali, come può essere quello estratto dai sensori di un dispositivo mobile. Come spiegato in conclusione al \autoref{chap:stato_arte}, le soluzioni proposte non sono adatte per essere implementate direttamente su dispositivo mobile, anche se dimostrano come un approccio deep learning possa essere un'ottima soluzione per gestire la dimensionalità del contesto. Per questi motivi in questo capitolo è descritto un nuovo sistema di raccomandazione context-aware basato su deep learning per sistemi mobili e pervasivi. Il sistema di raccomandazione è stato pensato per eseguire le fasi di training e inferenza su dispositivo mobile, e poter supportare un grande numero di feature di contesto. Per le caratteristiche appena elencate, questo nuovo RS è chiamato \textit{moveCARS} (MObile pervasiVE Context-Aware Recommender System).

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{immagini/full_RS.pdf}
  \caption{Architettura ad alto livello del sistema di raccomandazione}
  \label{fig:full_RS}
\end{figure}

\section{Architettura generale}
Generare raccomandazioni sul dispositivo mobile non è sufficiente per realizzare un RS pervasivo che non dipenda da un server centralizzato.  \`E necessario spostare anche le fasi di raccolta ed elaborazione dei dati su dispositivo mobile. Per questo motivo il modello moveCARS è inserito in un architettura più complessa, che si occupa di generare i dati che saranno input per il RS.
L'architettura ad alto livello è composta da quattro componenti:
\begin{enumerate}
 \item \textit{Sensing manager.} Il primo componente interagisce con il sistema operativo per raccogliere continuamente dati di contesto (come GPS e accelerometro), e dati che rappresentano informazioni sull'hardware e il software del dispositivo come lo stato del display e il livello di batteria. Tutte queste informazioni sono chiamate dati raw perchè non sono ancora state processate.
 
 \item \textit{Context modeling.} I dati raw prodotti dal sensing manager devono essere processati per inferire una rappresentazione più astratta del contesto dell'utente. A questo scopo, il componente context modeling (CM) raccoglie periodicamente gli ultimi dati disponibili del SM. Queste osservazioni sono processate per estrarre feature numeriche e categoriche che caratterizzano il contesto dell'utente locale (es. attività utente, luogo in cui si trova l'utente, temperatura). Il contesto è diviso in contesto fisico e sociale. Il contesto fisico è ottenuto  dai sensori del dispositivo dell'utente, mentre il contesto sociale è ottenuto considerando gli individui in prossimità dell'utente. Dell'insieme di feature eterogenee ottenute viene fatto l'encoding per poi essere combinate in un singolo vettore di feature che rappresenta una fotografia del contesto corrente dell'utente. L'insieme di feature che compongono il contesto fisico e sociale dell'utente sono descritte nel dettaglio nella \autoref{sec:context-info}.
 
 \item  \textit{Database.} Interagendo con altri dispositivi tramite comunicazione D2D, il device dell'utente scopre nuovi utenti e oggetti che sono identificati con delle feature che li caratterizzano. Oltre a questo il dispositivo riceve anche i feedback che questi utenti hanno generato sugli oggetti in un certo contesto. Tutte queste informazioni sono date in input al sistema di raccomandazione durante la fase di apprendimento per imparare a prevedere i feedback dell'utente locale. A training terminato, le feature degli oggetti presenti nel database, e le feature dell'utente corrente sono usate per produrre raccomandazioni. Le fasi di training e inferenza sono descritte nella \autoref{subsec: training}.
 
 \item \textit{Sistema di raccomandazione.} Le feature di contesto $c$ sono concatenate alle feature degli utenti $u$ e degli oggetti $i$ in un unico vettore. Questo vettore è dato in input ad una rete neurale, che restituisce valore 1 se per l'utente con feature $u$, l'oggetto con feature $i$ è rilevante nel contesto $c$, 0 altrimenti. L'input, la struttura e l'output della rete sono descritti nella \autoref{sec:ffnet}.
\end{enumerate}

\section{Sistema di raccomandazione} \label{sec:ffnet}
In questa sezione è descritto il sistema di raccomandazione moveCARS. Nella prima parte è descritto l'input, e in che modo si differenzia dai sistemi di raccomandazione collaborative filtering e content-based. Nella seconda parte è descritta nel dettaglio la struttura e il training della rete neurale che genera le raccomandazioni context-aware. In conclusione sono descritti i vantaggi e gli svantaggi del modello.

\subsection{Input} \label{subsec:input}
Solitamente l'input dei modelli collaborative filtering context-aware è composto da tuple \texttt{(user\_ID, item\_ID, rating, context)}, in cui \texttt{user\_ID} è l'utente che ha valutato l'oggetto \texttt{item\_ID} con una valutazione \texttt{rating} in una situazione descritta dal contesto \texttt{context}. Al posto che identificare l'oggetto con un valore numerico intero \texttt{item\_ID}, si possono usare delle feature che caratterizzano l'oggetto, esattamente nello stesso modo in cui sono solitamente descritti gli oggetti nei sistemi di raccomandazione content-based. Ad esempio, se si sta sviluppando un RS per consigliare ristoranti agli utenti, si può sostituire il valore \texttt{item\_ID} che identifica il ristorante con delle feature che lo caratterizzano nel dettaglio come il tipo di cibo servito, il prezzo medio, l'atmosfera, se ha sedute all'aperto, etc. Allo stesso modo si può sostituire il valore \texttt{user\_ID} con delle feature che descrivono l'utente. Queste possono essere feature non specifiche come età o genere, o feature specifiche per l'ambiente in cui il RS è implementato. Tornando all'esempio dei ristoranti, si potrebbe chiedere all'utente quanto è disposto a spendere per mangiare fuori e il tipo di cucina preferita. A feature di utente e oggetto si aggiungono le feature del contesto fisico e sociale generate dal modulo di Context modeling. Un'istanza di rating per il modello moveCARS è quindi una tupla \texttt{(user\_features, item\_features, rating, physical\_context, social\_context)}.

\begin{figure}
  \includegraphics[width=\linewidth]{immagini/ffnet_schema.png}
  \caption{Schema di moveCARS}
  \label{fig:ffnet}
\end{figure}

\subsection{Struttura della rete neurale}
Il vettore di feature appena descritto è dato in input ad una rete neurale che deve prevedere se l'utente caratterizzato da \texttt{user\_feature} è interessato all'oggetto caratterizzato da \texttt{item\_feature} nei contesti fisici e sociali \texttt{physical\_context} e \texttt{social\_context}. Si tratta quindi di un problema di classificazione binaria. Nei problemi di classificazione, l'obiettivo è prevedere il valore di una variabile che può assumere diversi valori discreti. I problemi di classificazione in cui una variabile può assumere solo due valori possibili (come 0 o 1) sono chiamati problemi di classificazione binaria \cite{hands-on-ml}.

\paragraph{Layer e neuroni}
La rete neurale scelta rientra nella categoria feed-forward fully connected. Una rete feed-forward non contiene cicli nel suo grafo \cite{Goodfellow-et-al-2016}, fully connected indica che ogni neurone del layer $i$ è connesso a tutti i neuroni del layer $i+1$. La rete ha un layer di input, un layer di output e $l$ layer nascosti. Il layer di input ha un numero di neuroni pari alle feature in ingresso (sommando user, item e context feature), il layer di output ha sempre un neurone, mentre il numero di neuroni nei layer nascosti $l$, e il numero di layer nascosti è calcolato facendo il tuning della rete tramite grid search, scegliendo la combinazione che ottiene i risultati migliori. In questa tesi è stato utilizzato lo stesso numero di neuroni in ogni layer nascosto, ma si può ad esempio adottare un design a torre in cui i layer più profondi contengono meno neuroni rispetto ai layer meno profondi.

\paragraph{Funzione di attivazione}
Una funzione di attivazione di un neurone definisce l'output di quel neurone in base all'insieme dei suoi input. Come funzione di attivazione dei layer nascosti ho scelto la funzione rectified linear unit (ReLU) definita come $f(x) = max\{0, x\}$. La funzione ReLU è consigliata per la maggior parte delle reti feed-forward \cite{Goodfellow-et-al-2016}, e ha diversi vantaggi rispetto a funzioni di attivazione come sigmoide e tanh: è più plausibile biologicamente, non viene saturata (a differenza di tanh e sigmoide che hanno un output massimo uguale a 1), e incoraggiando l'attivazione sparsa dei neuroni rende più difficile che si verifichi l'overfitting del modello durante il training \cite{relu}. Come funzione di attivazione del layer di output ho scelto la funzione sigmoide definita come 
$$f
(x) = \frac{1}{1+e^{-x}}
$$
che limita l'output della rete a valori tra 0 e 1, ed è quindi adatta per problemi di classificazione binaria \cite{choose-act-func}. 
\paragraph{Funzione di loss}
Una funzione di loss è una misura dell'errore tra il valore previsto dal modello e il valore effettivo. Come funzione di loss la scelta più comune per un classificatore binario è la funzione binary cross-entropy / log loss, definita come

$$
C = -\frac{1}{N} \sum_{i=1}^N y_i \cdot \log(p(y_i)) + (1-y_i) \cdot \log(1-p(y_i))
$$
dove $y$ è il valore reale del feedback di un utente su un oggetto (0 oppure 1), $p(y)$ è la probabilità predetta dalla rete che $y$ abbia valore 1, e $1-p(y_i)$ è la probabilità che $y$ abbia valore 0 \cite{cross-entropy}.

\paragraph{Ottimizzatore}
Un ottimizzatore è un algoritmo che modifica i pesi del modello in modo da minimizzare la funzione di loss e rendere le previsioni della rete più accurate possibile. Come ottimizzatore ho scelto Adam; nel paper in cui é introdotto viene dimostrato empiricamente di essere generalmente migliore rispetto ad altri algoritmi di ottimizzazione stocastici, e di risolvere in modo efficiente problemi di deep learning \cite{adam}. Adam ha diversi iperparametri configurabili, il più importante è il learning rate (chiamato $\alpha$ in Adam) che regola la velocità con cui il modello è adattato al problema. Gli altri parametri ($\beta_1, \beta_2, \varepsilon$) sono lasciati al valore di default della libreria Keras\footnote{\url{https://keras.io/api/optimizers/adam/}}. 

\paragraph{Epoche e batch size}
Epoche e batch size sono due parametri molto importanti da ottimizzare, il numero di epoche e la dimensione della batch size ideali sono calcolate tramite grid search nel \autoref{chap:risultati}. La batch size corrisponde al numero di campioni processati prima di aggiornare i parametri del modello. Il numero di epoche indica quante volte viene presentato alla rete il training set prima di concludere il training.

\bigskip
In \autoref{fig:ffnet} è rappresentata la struttura della rete neurale. In questo caso il modello ha due layer nascosti ed ogni layer contiene 10 neuroni, eccetto il layer di output che contiene un solo neurone.

\subsection{Training e inferenza} \label{subsec: training}
\myparagraph{Training}
Il processo di training di una rete neurale si basa sul trovare un insieme di pesi nella rete che permettano di risolvere nel modo migliore possibile un problema specifico. Il processo di training è iterativo, il che significa che procede passo dopo passo con piccoli aggiornamenti nei pesi del modello ad ogni iterazione, migliorando le performance del modello. Il processo di training iterativo di una rete neurale risolve un problema di ottimizzazione per dei parametri, (i pesi del modello) che ha come risultato un errore minimo durante la valutazione degli esempi nel training dataset. In ambiente mobile e pervasivo inizialmente il numero di esempi nel training dataset è limitato, e non rappresenta la conoscenza globale su tutti gli utenti, oggetti e rating. Questo non è un problema per moveCARS che può iniziare il training sui sample disponibili, per poi riprenderlo in un secondo momento quando il device utente tramite comunicazione D2D avrà scoperto nuovi sample. Questo è possibile per la struttura dell'input della rete neurale. L'input è un vettore formato dalla concatenazione di \texttt{user\_features, item\_features, physical\_context, social\_context}, la cui dimensione è fissata. Infatti utenti, oggetto e contesto sono definiti da un insieme di feature che non cambia nel tempo. Non è quindi necessario ridefinire il modello ogni volta che il numero di utenti o oggetti cambia, cioè quando sono scoperti nuovi utenti od oggetti.

\myparagraph{Inferenza}
Il task per un sistema di raccomandazione che fa classificazione è determinare se un utente è interessato ad un oggetto in una situazione descritta dal contesto fisico e sociale. La rete restituisce valore 1 se l'oggetto è rilevante, 0 altrimenti. Nel caso di moveCARS utenti e oggetti non sono definiti con degli ID numerici, come nei metodi collaborative filtering, ma da feature che li caratterizzano. Il task di moveCARS quindi può essere riformulato in modo più specifico come prevedere se all'utente con feature \texttt{user\_feature} interessa un oggetto con feature \texttt{item\_feature}, nel contesto fisico \texttt{physical\_context}, e nel contesto sociale \texttt{social\_context}.

\subsection{Vantaggi e svantaggi}
Di seguito sono elencati vantaggi e svantaggi del modello moveCARS. Dato che può essere considerato un sistema ibrido che unisce caratteristiche degli approcci collaborative filtering e content-based, eredita alcuni vantaggi e svantaggi da entrambe le categorie di algoritmi.

\myparagraph{Vantaggi:}
\begin{enumerate}
 \item \textit{Nessuna conoscenza del numero di utenti e oggetti.} Utenti e oggetti sono rappresentati con delle feature e non con il loro ID, non è necessario conoscere a priori quanti utenti e oggetti sono presenti nel sistema.
 \item \textit{Consigliare nuovi oggetti.} Il modello può consigliare nuovi oggetti anche se non ci sono valutazioni fornite dagli utenti, a differenza dei metodi collaborative filtering.
 \item \textit{Feature di contesto.} Il modello permette di integrare una grande quantità di feature di contesto che possono migliorare sensibilmente la capacità di predizione, come dimostrato nel \autoref{chap:risultati}.
 \item \textit{Serendipity:} il modello ha la capacità di fornire consigli fortuiti, il che significa che può consigliare elementi pertinenti per l'utente senza che il contenuto si trovi nel profilo dell'utente, a differenza dei metodi content-based.
\end{enumerate}

\myparagraph{Svantaggi:}
\begin{enumerate}
 \item \textit{Feature di utenti e oggetti:} la precisione del modello dipende dall'insieme delle feature che descrivono gli utenti e gli oggetti. \`E necessario selezionare attentamente le feature più adatte che descrivono utenti e oggetti in un'applicazione specifica.
  
 \item \textit{Raccomandazioni multi-domain:} è difficile creare RS multi-domain perché è complicato definire un insieme di feature che valgano per contenuti di natura diversa.
\end{enumerate}

\section{Informazioni di contesto} \label{sec:context-info}
In questa sezione sono descritte le informazioni di contesto fisico e sociale che vengono date in input al sistema di raccomandazione mobile. Nel \autoref{chap:risultati} è dimostrato che un insieme ampio di feature contestuali può portare a raccomandazioni molto più accurate, mentre un insieme di feature contestuali poco esteso ha un impatto decisamente minore.

\subsection{Contesto fisico}
Il contesto fisico è composto da tutte quelle informazioni rilevanti che possono essere utilizzate per caratterizzare la situazione di un utente. Le feature del contesto fisico sono ricavate dai sensori fisici dello smartphone di un utente (es. attività utente dall'accelerometro) e dal sistema operativo del telefono (es. stato display e livello batteria). A queste feature si vanno a integrare informazioni esterne come il meteo, la data e l'ora. Più nel dettaglio il contesto utente è caratterizzato dalle seguenti informazioni:

\paragraph{Posizione} Informazioni relative alla posizione geografica che includono latitudine, longitudine, precisione della posizione e direzione del movimento. La posizione geografica può essere usata per capire il luogo in cui si trova l'utente (a casa, al lavoro, etc.) o per raccomandare punti di interesse nelle vicinanze.

\paragraph{Movimento utente} Il movimento dell'utente include sia le attività svolte a piedi (correre e camminare), sia il movimento su un mezzo di trasporto (veicolo generico o bicicletta).

\paragraph{Applicazioni} Applicazioni in esecuzione sul dispositivo.

\paragraph{Audio}  Informazioni relative alla configurazione audio dello smartphone, incluse la modalità audio (suono, vibrazione, silenzioso), il volume delle notifiche, e lo stato dell'altoparlante (acceso o spento). Anche l'audio può migliorare il riconoscimento del contesto, per esempio durante una riunione la modalità audio potrebbe essere impostata su silenzioso e l'altoparlante spento.

\paragraph{Batteria} Informazioni relative alla batteria del telefono che includono il livello di carica e se la batteria si sta ricaricando. 

\paragraph{Display}  Stato dello schermo dello smartphone (acceso o spento), e orientamento dello schermo (verticale od orizzontale).

\paragraph{Dati dei sensori fisici} che includono sensori ambientali (es. temperatura dell'ambiente e luce), sensori di movimento (es. accelerometro e giroscopio) e sensori di posizione (es. rotazione e prossimità).

\paragraph{Celle di rete} Lista delle celle di rete mobile rilevate dal dispositivo. Per ogni cella si identifica il tipo di tecnologia (es. GSM o LTE), l'ID della cella, e la forza del segnale. La rete mobile può migliorare l'identificazione della posizione dell'utente.

\paragraph{Wi-Fi} Lista di tutti gli access point Wi-Fi disponibili in prossimità, e se l'utente è connesso ad uno di essi.

\paragraph{Meteo} Informazioni relative alle condizioni meteo che includono il tempo in atto (es. nuvoloso, piovoso, soleggiato), la temperatura, l'umidità e la velocità del vento.

\paragraph{Data e ora} Dalla data si possono generare feature come il giorno della settimana, la stagione, comprendere se è il fine settimana o un periodo di vacanza, etc. Dall'orario invece si può capire il momento della giornata (mattina, pomeriggio, sera, notte).

\subsection{Contesto sociale} \label{subsec:social-context}
Il contesto sociale si riferisce all'insieme di persone con cui l'utente ha interazioni sociali durante la vita giornaliera, come lavorare con i colleghi o messaggiare con gli amici. \'E stato provato in letteratura che esiste una forte correlazione tra le attività umane e i dati sociali \cite{ego-net}. Questo implica che modellare una rete specifica per l'utente di relazioni sociali può contribuire a sottolineare le differenze tra i vari contesti in cui è coinvolto.

\begin{figure}
  \centering
  \includegraphics[scale=0.50]{immagini/ego-network.png}
  \caption{Ego network}
  \label{fig:ego-network}
  \cite{ego-net}
\end{figure}

\subsubsection{Ego Network}
Una ego network è una rete sociale composta da un individuo chiamato ego, e dalle persone con cui l'ego ha un collegamento sociale, chiamati alter. I legami sociali in una ego network non hanno tutti la stessa importanza. Ogni individuo ha solo pochi collegamenti forti e molti collegamenti deboli, dovuti alla capacità umana di gestire un numero limitato di relazioni sociali. Una rappresentazione della ego network è mostrata in \autoref{fig:ego-network}: l'ego è il punto rosso al centro dei quattro cerchi concentrici chiamati layer, in cui gli alter sono distribuiti in base alla forza del legame sociale con l'ego. Il cerchio più interno (support clique) è il layer più piccolo, e contiene solo pochi alter che rappresentato le relazioni sociali più forti con l'ego. Il secondo layer (sympathy group) contiene le persone che possono essere considerati gli amici più cari. Il terzo cerchio (affinity group) è composto da amici e membri della famiglia meno vicini, mentre l'ultimo layer include persone con cui l'individuo ha interazioni sociali occasionali \cite{ego-net}.

\subsubsection{Modellare il contesto sociale dell'utente}
Per modellare il contesto sociale di un utente in ambiente mobile, si caratterizzano le interazioni sociali usando le seguenti sorgenti di dati: (i) chiamate telefoniche e log degli SMS, (ii) dati di prossimità, e (iii) attività svolte dall'utente sugli online social networks (OSN).

Il primo step per costruire l'ego network di un individuo è stimare la forza dei legami sociali con i suoi alter. Un buon indicatore della forza delle relazioni sociale tra due persone è data dal numero di interazioni che le due persone hanno avuto in passato. Basandosi su questa considerazione, per modellare la forza dei legami sociali dell'utente online, sono presi in considerazione diverse attività svolte dall'utente su OSN, inclusi commenti, reazioni (come ``mi piace") e persone menzionate. Formalmente, la forza dei legami sociali virtuali tra l'ego $e$ ed uno dei sui alter $a$, $\omega_{osn}(e,a)$ è calcolata nel modo seguente:
\begin{equation}	
	\omega_{osn}(e,a)=\sum_{v_\in V}I_S (e, a)
\end{equation}

dove $V$ è l'insieme delle sorgenti di dati degli OSN nominate prima, e la funzione $I_S (e, a)$ calcola il numero di interazioni tra $e$ ed $a$ per una data sorgente di dati. 

Per caratterizzare i link sociali fisici di un utente si calcola il numero di interazioni con altre persone basandosi su telefonate, SMS e contatti faccia a faccia inferiti usando tecnologie wireless disponibili sugli smartphone. In particolare sono considerate il Bluetooth (BT) e il Wi-Fi Direct (WFD), per scoprire persone che sono abbastanza vicine da aver un interazione con l'utente locale. Sono filtrati i dispositivi che non si trovano in prossimità dell'utente, e sono selezionati solo i dispositivi personali dell'utente, in modo tale da non considerare stampanti, smart TV etc. In modo simile ai link sociali virtuali, si definisce la forza dei legami fisici sociali tra l'ego $e$ e un alter $a$, $\omega_{phy}(e, a)$ come il numero delle loro interazioni tramite telefonate, SMS, e prossimità fisica come segue:
\begin{equation}
	\omega_{phy}(e, a) = \sum_{p \in P}I_p(e,a)
\end{equation}

dove $P$ è l'insieme delle sorgenti fisiche considerate, e $I_p(e,a)$ rappresenta il numero di interazioni tra due utenti per una data sorgente di dati. Infine, la forza complessiva del collegamento sociale tra $e$ ed $a$ è data dalla combinazione lineare delle interazioni online e fisiche descritte prima:
\begin{equation}
\label{eqn:final-weights}
	\omega_s(e,a) = \lambda \cdot \omega_{osn}(e,a) + (1 - \lambda)
	\cdot \omega_{phy}(e,a)
\end{equation}
con il parametro $\lambda$ che regola l'importanza delle interazioni sociali e fisiche. Per ogni alter, solo l'ultimo peso calcolato è mantenuto in memoria, e viene aggiornato quando nuove interazioni sociali sono identificate. I link sociali tra l'utente locale e le altre persone sono raggruppate in base al peso calcolato nell'\autoref{eqn:final-weights}. L'output finale è un array di valori in cui ogni elemento rappresenta la percentuale di utenti attivi in ogni cerchio della ego network di un utente \cite{ego-net}. 

La \autoref{fig:ego-array} mostra un esempio del processo di riconoscimento del contesto. Basandosi sui dati raccolti dal Sensing Manager, viene riconosciuta la rilevanza degli alter per l'utente locale in base a livello in cui essi sono posizionati nella ego network. L'output caratterizza il contesto sociale dell'utente, indicando chiaramente che sta interagendo con tre persone diverse che si trovano nel secondo, terzo e quarto layer rispettivamente.

\begin{figure}
  \centering
  \includegraphics[scale=0.80]{immagini/ego-array.png}
  \caption{Riconoscimento del contesto sociale di un utente}
  \label{fig:ego-array}	
  \cite{ego-net}
\end{figure}

% 
%			CAPITOLO 4: Datasets
% 

\chapter{Dataset} \label{chap:datasets}
In questo capitolo sono descritti i dataset context-aware usati per valutare il modello moveCARS, e nel \autoref{chap:risultati}, confrontarlo con altre soluzioni stato dell'arte. Uno dei problemi nella valutazione dei CARS, è la scarsità di dataset pubblici che contengono informazioni di contesto ad alta dimensionalità. Molti dataset infatti hanno informazioni di contesto limitate unicamente al timestamp dei feedback come Yelp\footnote{\url{https://www.yelp.com/dataset}} e nowplaying-rs\footnote{\url{https://zenodo.org/record/3247476\#.YK9FxqgzY2x}}. In generale è difficile trovare dataset che caratterizzano il contesto fisico e sociale dell'utente con una grande quantità di feature. Dato che il modello moveCARS si inserisce in un ambiente mobile e pervasivo, ho selezionato due dataset context-aware, in cui i feedback dell'utente corrispondono alle applicazioni in esecuzione sui dispositivi Android degli utenti: (i) My Digital Footprint\footnote{\url{https://github.com/contextkit/MyDigitalFootprint}}, (ii) Frappe\footnote{\url{https://www.baltrunas.info/context-aware}}.

\section{Frappe}
Frappe \cite{frappe} è un dataset di feedback impliciti pubblicamente disponibile collezionato da un sistema di raccomandazione context-aware di applicazioni Android. L'applicazione che monitora l'utilizzo degli smartphone, è stata installata da 957 utenti che hanno utilizzato un totale di 4082 applicazioni. Le informazioni raccolte descrivono la frequenza di utilizzo di un'applicazione da parte di un utente per un periodo di 2 mesi. Il numero totale di feedback presenti è 96203. Il task per un recommender system su questo dataset è prevedere se un'applicazione Android è rilevante per un utente in un determinato contesto.

\subsection{Feature di contesto}
Le feature di contesto descrivono la situazione dell'utente nel momento in cui ha utilizzato un'applicazione Android. Frappe può essere considerato un dataset con un contesto a bassa dimensionalità, e non contiene informazioni raccolte dai sensori dei dispositivi Android. Di seguito sono descritte tutte le feature di contesto presenti nel dataset.

\paragraph{Daytime} è il momento della giornata in cui un'applicazione è stata utilizzata. La giornata è divisa in sette momenti diversi: morning, noon, afternoon, evening, sunset, sunrise, night.

\paragraph{Weekday} è il giorno della settimana in cui un'applicazione è stata utilizzata. I possibili valori sono ovviamente i sette giorni della settimana.

\paragraph{Isweekend} indica se un'applicazione è stata utilizzata nel fine settimana oppure in un giorno lavorativo. Può assumere due valori diversi: weekend e workday.

\paragraph{Homework} indica se l'utente si trova al lavoro o a casa. Può assumere tre diversi valori: work, home, unknown.

\paragraph{Weather} descrive la situazione meteo nel momento in cui un'applicazione è stata utilizzata. Può assumere nove valori differenti: sunny, cloudy, foggy, stormy, rainy, snowy, drizzle, sleet, unknown.

\paragraph{Country} indica la nazione in cui si trovava l'utente nel momento in cui ha utilizzato un'applicazione. Ci sono 80 stati diversi, ma il 55\% dei feedback sono stati generati da USA, spagna e regno unito.

\paragraph{City} è un valore numerico che rappresenta la città in cui si trovava l'utente nel momento in cui ha utilizzato un'applicazione. Ci sono 233 città diverse, ma per il 40\% dei feedback la città è sconosciuta.  

\bigskip \noindent
Delle feature di contesto appena descritte sono eliminate homework, country e city perché poco utili a definire il contesto dell'utente. In particolare city è stata eliminata perché contiene troppi valori sconosciuti, ed in corrispondenza di una città sconosciuta c'è spesso anche il valore della feature country sconosciuta. Anche homework è stato eliminato perché il numero di feedback che hanno la feature homework con valore unknown è pari al 78\%. Country non viene considerata perché la maggior parte dei feedback utente sono associati a poche nazioni, e ci sono un gran numero di nazioni a cui sono associati un numero non sufficiente di feedback.
Le feature rimaste compongono il contesto: daytime, weekday, isweekend, weather. L'unica di queste feature che può assumere valore unknown è weather. Le righe del dataset in cui weather è unknown sono eliminate. Il risultato è un dataset con 78335 righe, 857 utenti e 3180 oggetti.

Per quanto riguarda l'encoding, essendo tutte variabili categoriche sono codificate con one-hot encoding. Il vettore del contesto risultato contiene 24 features: 7 per daytime, 7 per weekday, 8 per weather e 2 per isweekend.

\subsection{Feedback}
Qualsiasi dataset per sistemi di raccomandazione ha tre feature fondamentali: user, item, rating. User e item sono valori numerici che identificano univocamente gli utenti e gli oggetti. Il rating in Frappe è il numero di volte in cui un oggetto (un'applicazione) è stata utilizzata da un utente in un determinato contesto. Ad esempio, se una riga del dataset è composta da \texttt{(user:1, item:20, rating:50, daytime:morning, weekday:monday)}, significa che l'utente 1, ha utilizzato l'applicazione 20, il lunedì mattina, 50 volte. Il numero di volte è ottenuto sommando tutti gli utilizzi durante il periodo di raccolta dei dati. Il valore minimo dei rating è 1, il valore massimo 21262, e la media 88.26. Questi rating vanno convertiti in feedback impliciti con valore 0 o 1 per essere compatibili con moveCARS, come spiegato nella \autoref{subsec:input}. Considerando il valore medio dei rating, e cercando di avere un dataset bilanciato, ho deciso di convertire tutti i rating con valore maggiore di 4 in feedback con valore 1, mentre i rating con valore 4 o minore in feedback negativi. Il risultato è un dataset con il 62\% di feedback positivi (48604 data sample).

\subsection{Feature degli oggetti}
Le feature degli oggetti sono caratteristiche che descrivono le applicazioni usate dagli utenti di Frappe. Il dataset contiene tre feature rilevanti per il task di classificazione: la categoria dell'applicazione, la lingua, e il costo.

\paragraph{Category} è la categoria delle applicazioni ottenuta dal Google Play Store. In Frappe le applicazioni sono divise in 23 categorie che descrivono la loro funzionalità principale (es. videogiochi, notizie, social). Come si può vedere in \autoref{fig:frappe-categories}, il numero di data sample per ogni categoria è molto sbilanciato: la categoria communication che comprende applicazioni di messaggistica come WhatsApp e Telegram ha più di 20k data sample. La seconda categoria più popolare è social che comprende applicazioni come Facebook, Instagram e Twitter.
\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{immagini/frappe-category.png}
  \caption{Numero di data sample per ogni categoria di applicazioni nel dataset Frappe}
  \label{fig:frappe-categories}
\end{figure}

\paragraph{Language} indica la lingua dell'applicazione ottenuta dal Google Play Store. Dato che il 96\% dei data sample hanno applicazioni in lingua inglese, ho assegnato a tutte le altre lingue il valore other.

\paragraph{Cost} indica se l'applicazione è gratuita o a pagamento.

\bigskip \noindent
Come per le feature di contesto, anche le feature degli oggetti sono variabili categoriche. Vengono codificate con one-hot encoding; il risultato è un vettore di 27 feature: 23 per la categoria, 2 per la lingua, e 2 per il costo.

\subsection{Feature degli utenti}
Il dataset Frappe non contiene nessuna informazione associata agli utenti oltre all'ID dell'utente. Per questo motivo, ho generato le feature degli utenti a partire dalle feature degli oggetti e di contesto.

\paragraph{User category} indica la categoria di applicazioni più utilizzata dall'utente. Come era prevedibile dalla distribuzione delle categorie mostrata in \autoref{fig:frappe-categories}, le categorie preferite dagli utenti sono communication e social.

\paragraph{User weekday} indica il giorno della settimana in cui l'utente ha generato il maggior numero di feedback. I giorni più popolari sono venerdì e sabato.

\paragraph{User daytime} indica il momento della giornata in cui l'utente ha generato il maggior numero di feedback. I momenti della giornata più popolari sono la sera e il pomeriggio.

\paragraph{User weather} indica la condizione meteo in cui l'utente ha generato il maggior numero di feedback. Le condizioni meteo più popolari sono nuvoloso e soleggiato.

\paragraph{User weekend} indica se l'utente ha generato più feedback in settimana o nel weekend. La maggior parte degli utenti (85\%), ha generato più feedback in settimana.

\paragraph{Uses paid apps} indica se l'utente ha mai utilizzato un'applicazione a pagamento. Il 59\% degli utenti ha utilizzato almeno una volta un'applicazione a pagamento.

\bigskip \noindent
Come le feature di contesto e degli oggetti, anche le feature degli utenti sono tutte variabili categoriche. Vengono codificate con one-hot encoding in un vettore di 47 feature: 22 per user category, 7 per user weekday, 7 per daytime, 7 per user weather, 2 per user weekend, 2 per uses paid apps.

Ricapitolando, il dataset Frappe processato contiene 78335 data sample, 857 utenti e 3180 oggetti. Oltre alle colonne user, item e feedback, il dataset contiene 47 feature degli utenti, 22 feature degli oggetti, e 24 feature di contesto.

\section{My Digital Footprint}
My Digital Footprint (MDF) \cite{mdf} è un nuovo dataset composto da dati di sensori di smartphone, informazioni di prossimità fisica, e interazioni sugli online social network. Il dataset include due mesi di misurazioni e informazioni collezionate dai dispositivi personali di 31 volontari, nel loro ambiente naturale, senza limitare il loro comportamento usuale. I dati raccolti costituiscono un insieme completo di informazioni per descrivere il contesto utente in ambiente mobile. 

\subsection{Negative sampling}
Il task per un recommender system su questo dataset è prevedere se un'applicazione Android è rilevante per un utente in un determinato contesto. In MDF sono presenti solo i log indicanti che un'applicazione era in esecuzione sul dispositivo dell'utente, ad un certo timestamp $t$, in una situazione contestuale $c$. Per eseguire il training di una rete neurale sono però necessari degli esempi negativi, i quali indicano che un'applicazione non era in uso da parte di un utente, al tempo $t$ in una specifica situazione contestuale. Ogni data sample ha associata una label, che definisce il contesto dell'utente ad alto livello con i seguenti valori: \texttt{home, school, workplace, external school} (dove gli autori del dataset incontravano i volontari), \texttt{free Time}, e \texttt{holiday}. Questa etichetta non è usata come feature di contesto, ma per fare negative sampling del dataset. 
L'algoritmo \ref{alg:neg-sampling} mostra il procedimento: per ogni sample $d$ nel dataset $D$ con struttura $(user, item, feedback, context, label)$, vengono identificate le label in cui $d.item$ non è mai stato utilizzato (riga 2). Per ogni label $n$ viene scelto in modo casuale un sample $\in D$ con label = $n$ (riga 4). Di questo sample viene mantenuto solo il contesto $context_{neg}$ scartando user, item e feedback. Il sample negativo $d_{neg}$ è ottenuto concatenando $d.user$ e $d.item$, con 0 (il feedback negativo) e $context_{neg}$ (riga 6).  $d_{neg}$ è aggiunto al dataset $D_{neg}$ che contiene solo sample negativi (riga 7). In ultimo il dataset $D_{neg}$ è unito al dataset $D$ ed è eliminata la colonna corrispondente alle label (righe 10 e 11). Il risultato è una dataset con 31 utenti, 338 oggetti, e 73176 feedback, di cui il 66\% con valore 1.

\begin{algorithm}
\floatname{algorithm}{Algoritmo}
\caption{Negative sampling di MDF}
\label{alg:neg-sampling}
 \hspace*{\algorithmicindent} \textbf{Input:} $D$ - dataset \\
 \hspace*{\algorithmicindent} \textbf{Output:} $D_{neg}$ - dataset 
$D$ with negative samples \\ 
\begin{algorithmic}[1]

\FORALL{$d \in D$} 
	\STATE $labels_{neg} \leftarrow$ labels where $d.item$ was never used
	\FORALL{$n \in labels_{neg}$}
		\STATE $context_{neg} \leftarrow$ context of a random data sample  $\in D$ with $label = n$
		\STATE $feedback \leftarrow$ 0
		\STATE $d_{neg} \leftarrow$ concatenate $d.user$, $d.item$, $feedback$ and $context_{neg}$
		\STATE $D_{neg} \leftarrow$ $D_{neg} \cup d_{neg}$ 
		
	\ENDFOR
\ENDFOR

\STATE $D_{neg} \leftarrow$ $D \cup D_{neg}$
\STATE $D_{neg} \leftarrow$ drop all labels from samples $ \in D_{neg}$
\STATE Return $D_{neg}$

\end{algorithmic}
\end{algorithm}


\subsection{Feature di contesto}
Il dataset MDF contiene numerosi dati estratti dai sensori degli smartphone dell'utente. Dato che le feature sono davvero molte, di seguito sono elencate solo quelle selezionate che compongono il dataset finale.

\paragraph{Attività utente}  L'attività utente riconosciuta da
 Android Activity Recognition system\footnote{\url{https://developers.google.com/location-context/activity-recognition}};
include sia movimenti a piedi che su mezzi di trasporto. Le attività
possibili sono \texttt{in vehicle, on bicycle, on foot, running, still,
tilting, walking, unknown}. Ogni feature rappresenta la probabilità da 0 a 100 che l'utente stia facendo quell'attività specifica.

\paragraph{Modalità audio} indica se la modalità audio del telefono è impostata su silenzioso, vibrazione o suono.

\paragraph{Volume} \texttt{Alarm volume, music volume, notification volume} e \texttt{ring volume}, sono quattro feature con valore tra 0 e 1 che indicano il livello audio della sveglia, della musica, delle notifiche e della suoneria.

\paragraph{Musica} \texttt{music active} è un valore booleano che indica se il dispositivo sta riproducendo della musica. Se la musica è riprodotta dallo speaker del telefono o dalle cuffie è identificato dalle feature \texttt{speaker on}, e \texttt{headset connected}.

\paragraph{Batteria} Associate alla batteria ci sono due feature: \texttt{level} indica la carica della batteria (molto bassa, bassa, media, alta, carica) \texttt{charging} è un valore booleano che indica se la batteria si sta ricaricando oppure no.

\paragraph{Schermo} Associate al display ci sono due feature: \texttt{state} indica se il display è spento, acceso, o se si sta per spegnere. \texttt{Rotation} indica se l'utente sta usando il telefono in verticale o in orizzontale.

\paragraph{Meteo} Il meteo è descritto da sei variabili diverse: temperatura, umidità, pressione atmosferica, velocità del vento, nuvole, e se ha piovuto nelle ultime tre ore.

\paragraph{Wifi} La feature \texttt{connected} indica se il dispositivo dell'utente è connesso oppure no ad una rete Wi-Fi

\paragraph{Data e ora} Dai timestamp dei feedback in formato \texttt{YYYY-MM-DD HH:MM:SS} sono calcolate come per il dataset Frappe le feature daytime (mattina, pomeriggio, sera, e notte) weekday e isweekend. Oltre a queste, con la libreria Python Holidays\footnote{\url{https://pypi.org/project/holidays/}}, è calcolato se è un giorno di vacanza o no, in base al calendario delle festività italiano.

\paragraph{Feature sociali} Le feature sociali sono ottenute dall'ego network descritta nella \autoref{subsec:social-context}. Ci sono quattro feature \texttt{social\_c1, social\_c2, social\_c3} che corrispondono alle cerchie sociali della ego network, e indicano la percentuale di alter vicino all'utente nel momento in cui ha utilizzato un'applicazione. Il secondo gruppo di feature chiamate \texttt{layer\_1, layer\_2, layer\_3, layer\_4} indicano il layer dell'utente da cui è stata ricevuta la raccomandazione. Questo presuppone un dataset diverso per ogni utente, dato che l'ego network è personale per ogni utente (es. uno sconosciuto per l'utente 1, potrebbe essere un amico per l'utente 2).

\bigskip \noindent
Le feature categoriche sono codificate con one-hot encoding, mentre le feature numeriche sono normalizzate. Il risultato è un vettore che contiene 63 feature che descrivono il contesto fisico dell'utente, e 8 feature che descrivono il contesto sociale dell'utente.

\subsection{Feature degli oggetti}

\paragraph{Category}
è la categoria delle applicazioni ottenuta dal Google Play Store. In
MDF le applicazioni sono divise in 26 categorie che descrivono la loro funzionalità principale (es. videogiochi, notizie, social). Come si può vedere dalla \autoref{fig:mdf-categories}, anche in MDF il numero di data sample per ogni categoria è molto sbilanciato: la categoria communication che comprende applicazioni di messaggistica come Whatsapp e Telegram ha più di
20k data sample. La seconda categoria più popolare è social che comprende applicazioni come Facebook, Instagram e Twitter. La categoria è codificata con one-hot encoding.

\begin{figure}
  \centering
  \includegraphics[width=\linewidth]{immagini/mdf-category.png}
  \caption{Numero di data sample per ogni categoria di applicazioni nel dataset My Digital Footprint}
  \label{fig:mdf-categories}
\end{figure}

\subsection{Feature degli utenti}
Come per Frappe, il dataset MDF non contiene nessuna informazione sugli utenti. Per questo motivo ho generato quattro feature utente dalle feature di contesto e degli oggetti.

\paragraph{User category} indica la categoria di applicazioni più utilizzata dall'utente. Anche in questo caso le categorie più popolari sono Communication e Social.

\paragraph{User weekday} indica il giorno della settimana in cui l'utente ha generato il maggior numero di feedback. I giorni più popolari sono giovedì e venerdì.

\paragraph{User daytime} indica il momento della giornata in cui l'utente ha generato il maggior numero di feedback. Il momento della giornata più popolare è la mattina.

\paragraph{User weekend} indica se l'utente ha generato più feedback in settimana o nel weekend. La maggior parte degli utenti (98\%), ha generato più feedback in settimana.

\bigskip \noindent
Come le feature degli oggetti, anche le feature degli utenti sono tutte variabili categoriche. Vengono codificate con one-hot encoding in un vettore di 27 feature: 14 per user category, 7 per user weekday, 4 per user daytime, 2 per User weekend.

Ricapitolando, il dataset MDF processato contiene 73176 data sample, 31 utenti e 338 oggetti. Oltre alle colonne user, item e feedback, il dataset contiene  27 feature degli utenti, 26 feature degli oggetti, e 71 feature di contesto.


% 
%			CAPITOLO 5: Risultati
% 

\chapter{Risultati} \label{chap:risultati}


% 
%			CAPITOLO 6: Conclusioni e sviluppi futuri
% 

\chapter{Conclusioni} \label{chap:conclusioni}

\section{Conclusioni}

Conclusioni...

\section{Sviluppi futuri}

Sviluppi futuri...



%
%			BIBLIOGRAFIA
%

\bibliographystyle{unsrt}
\bibliography{bibliografia}
\addcontentsline{toc}{chapter}{Bibliografia}


\end{document}


 
